#!/bin/bash

# description: Manage the freeside-queued script service, SYS-V style 
# chkconfig: 2345 10 90


ARG1=${1}
SERVICE=freeside-selfservice-server
LOCKFILE=/var/lock/subsys/${SERVICE}
PIDFILE=/var/run/${SERVICE}.USERMACHINE.pid


if [ -f /etc/rc.d/init.d/functions ]
then
    . /etc/init.d/functions
elif [ -f /lib/lsb/init-functions ]
then
    . /lib/lsb/init-functions
fi

if [ -f %%%FREESIDE_DEFAULTS%%% ]
then
    . %%%FREESIDE_DEFAULTS%%%
fi

if [ -z ${SELFSERVICE_USER} ] 
then
    SELFSERVICE_USER=%%%SELFSERVICE_USER%%%
fi

# 0:	program is running or service is OK
# 1:	program is dead and /var/run pid file exists
# 2:	program is dead and /var/lock lock file exists
# 3:	program is not running
statusfunc() {
    if [ -f ${LOCKFILE} ]
    then
        MACH_RUNNING=0
        MACH_DEAD=0
        MACH_STOPPED=0
        # Loop over machines
        for MACHINE in $SELFSERVICE_MACHINES
        do
            USERMACHINE="${SELFSERVICE_USER}.${MACHINE}"
            MYPIDFILE=`echo $PIDFILE | sed "s/USERMACHINE/$USERMACHINE/"`
            
            if [ -f ${MYPIDFILE} ]
            then
                PID=`cat $MYPIDFILE`
                if ps -p ${PID} > /dev/null
                then
                    MACH_RUNNING=$((MACH_RUNNING + 1))
                else
                    MACH_DEAD=$((MACH_DEAD + 1))
                fi
            else
                MACH_STOPPED=$((MACH_STOPPED + 1))
            fi
        done

        if [ $MACH_DEAD -gt 0 ] 
        then
            return 1
        fi
        if [ $MACH_RUNNING -ge 0 -a $MACH_STOPPED -eq 0 ]
        then
            return 0
        fi

    fi
    return 3
}

startfunc() {
    if statusfunc
    then
        action "Already running ${SERVICE} " /bin/false
    else
        # Loop over machines
        STARTERR=0
        for MACHINE in $SELFSERVICE_MACHINES
        do
            ${SERVICE} $SELFSERVICE_USER $MACHINE
            RETVAL=$?
            action "Starting ${SERVICE} " /bin/true
            if [ $RETVAL != 0 ]
            then
                STARTERR=1
            fi
        done
        if [ $STARTERR -eq 0 ]
        then
            touch ${LOCKFILE}
            return 0
        fi
        return 1
    fi
}

stopfunc() {
    if statusfunc
    then
        for MACHINE in $SELFSERVICE_MACHINES
        do
            USERMACHINE="${SELFSERVICE_USER}.${MACHINE}"
            MYPIDFILE=`echo $PIDFILE | sed "s/USERMACHINE/$USERMACHINE/"`
            echo -n "Stopping ${SERVICE} service for $MACHINE"
            killproc -p ${MYPIDFILE}
            echo
        done
        rm -f ${LOCKFILE}
    else
        action "Service not running" /bin/false
    fi
}

restartfunc() {
    stopfunc
    startfunc
} 

# echo_status function
echo_statusfunc() {
    # we need a way of displaying the status to the end user if called with the parameter status. This status function will check for pid or lockfile
    echo -n $SERVICE
    for MACHINE in $SELFSERVICE_MACHINES
    do
        USERMACHINE="${SELFSERVICE_USER}.${MACHINE}"
        MYPIDFILE=`echo $PIDFILE | sed "s/USERMACHINE/$USERMACHINE/"`
        status -p $MYPIDFILE
    done
}

# main loop/case statement
# The main loop is done with a case statment, and we no longer call $0 directly, which saves shell instances and makes our scripts more efficent.
case $ARG1 in 

start)
    # if our parameter is 'start' we should run this
    startfunc
;;

stop)
    # if our parameter is 'stop' we should run this
    stopfunc
;;

restart)
    # if our parameter is 'restart' we should run this
    restartfunc
;;

status)
    # display the status of our service using the echo_statusfunc function
    echo_statusfunc
;;

*)
    # catchall case statement... if we get a parameter that we don't understand show the syntax and exit with and error code of >0
    echo "Syntax Error... usage: $0 (start|stop|restart|status)"
    exit 1
;;

# close up that case
esac
